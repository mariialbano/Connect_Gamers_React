const express = require('express');
const router = express.Router();
const multer = require('multer');
const { v4: uuidv4 } = require('uuid');
const QRCode = require('qrcode');
const pool = require('../config/database');
const azureFaceService = require('../services/azureFaceService');

let faceImageColumnEnsured = false;

async function ensureFaceImageColumn() {
    if (faceImageColumnEnsured) return;
    try {
        await pool.query('ALTER TABLE usuarios ADD COLUMN IF NOT EXISTS face_image BYTEA');
        faceImageColumnEnsured = true;
    } catch (err) {
        console.error('‚ö†Ô∏è N√£o foi poss√≠vel garantir a coluna face_image:', err.message);
    }
}

// Configura√ß√£o do multer para upload de imagens
const storage = multer.memoryStorage();
const upload = multer({
    storage: storage,
    limits: {
        fileSize: 5 * 1024 * 1024 // 5MB m√°ximo
    },
    fileFilter: (req, file, cb) => {
        if (file.mimetype.startsWith('image/')) {
            cb(null, true);
        } else {
            cb(new Error('Apenas arquivos de imagem s√£o permitidos!'), false);
        }
    }
});

// Fun√ß√£o para limpar tokens expirados
async function cleanExpiredTokens() {
    try {
        await pool.query('DELETE FROM verification_tokens WHERE expires_at < NOW()');
    } catch (error) {
        console.error('Erro ao limpar tokens expirados:', error);
    }
}

// Rota para gerar QR Code de verifica√ß√£o
router.post('/generate-qr', async (req, res) => {
    try {
        const { userId, username } = req.body || {};

        if (!userId && !username) {
            return res.status(400).json({ error: 'ID do usu√°rio ou username √© obrigat√≥rio' });
        }

        // Verificar se o usu√°rio existe
        let user = null;
        if (userId) {
            const byId = await pool.query('SELECT id, is_verified FROM usuarios WHERE id = $1', [userId]);
            if (byId.rows.length > 0) {
                user = byId.rows[0];
            }
        }

        // Fallback: procurar por username (case-insensitive)
        if (!user && username) {
            const byUsername = await pool.query('SELECT id, is_verified FROM usuarios WHERE lower(usuario) = lower($1) LIMIT 1', [username]);
            if (byUsername.rows.length > 0) {
                user = byUsername.rows[0];
            }
        }

        if (!user) {
            console.warn('generate-qr: usu√°rio n√£o encontrado. Recebido =>', { userId, username });
            return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
        }

        if (user.is_verified) {
            return res.status(400).json({ error: 'Usu√°rio j√° est√° verificado' });
        }

        // Limpar tokens expirados
        await cleanExpiredTokens();

        // Verificar se j√° existe um token v√°lido para este usu√°rio
        const existingTokenResult = await pool.query(
            'SELECT token FROM verification_tokens WHERE user_id = $1 AND expires_at > NOW() AND used = false',
            [user.id]
        );

    let token;

        if (existingTokenResult.rows.length > 0) {
            // Usar token existente
            token = existingTokenResult.rows[0].token;
        } else {
            // Criar novo token
            token = uuidv4();
            const expiresAt = new Date(Date.now() + 5 * 60 * 1000); // 5 minutos

            await pool.query(
                'INSERT INTO verification_tokens (token, user_id, expires_at) VALUES ($1, $2, $3)',
                [token, user.id, expiresAt]
            );
        }

        // Gerar QR Code usando a origem da requisi√ß√£o (suporta acesso via IP da LAN)
        const origin = `${req.protocol}://${req.get('host')}`;
        // O frontend est√° servido pelo backend (build est√°tico), ent√£o usa a mesma origem
        // FRONTEND_URL pode ser usado para sobrescrever se necess√°rio (ex: ngrok URL p√∫blica)
        const frontendBase = process.env.FRONTEND_URL || origin;
        const verificationUrl = `${frontendBase}/verify/${token}`;
        const qrCodeDataUrl = await QRCode.toDataURL(verificationUrl);

        res.json({
            success: true,
            qrCode: qrCodeDataUrl,
            token: token,
            verificationUrl,
            expiresIn: 5 * 60 * 1000 // 5 minutos em millisegundos
        });

    } catch (error) {
        console.error('Erro ao gerar QR Code:', error);
        res.status(500).json({ error: 'Erro interno do servidor' });
    }
});

// Rota para verificar token
router.get('/verify-token/:token', async (req, res) => {
    try {
        console.log('üîç [VERIFY-TOKEN] Requisi√ß√£o recebida:', { 
            token: req.params.token?.substring(0, 8) + '...', 
            ip: req.ip,
            origin: req.get('origin')
        });
        
        const { token } = req.params;

        if (!token) {
            console.log('‚ùå [VERIFY-TOKEN] Token n√£o fornecido');
            return res.status(400).json({ error: 'Token √© obrigat√≥rio' });
        }

        // Limpar tokens expirados
        await cleanExpiredTokens();

        // Verificar se o token existe e √© v√°lido
        const tokenResult = await pool.query(
            `SELECT vt.*, u.nome, u.usuario 
             FROM verification_tokens vt 
             JOIN usuarios u ON vt.user_id = u.id 
             WHERE vt.token = $1 AND vt.expires_at > NOW() AND vt.used = false`,
            [token]
        );

        if (tokenResult.rows.length === 0) {
            console.log('‚ùå [VERIFY-TOKEN] Token inv√°lido ou expirado:', token.substring(0, 8) + '...');
            return res.status(400).json({ error: 'Token inv√°lido ou expirado' });
        }

        const tokenData = tokenResult.rows[0];
        console.log('‚úÖ [VERIFY-TOKEN] Token v√°lido para usu√°rio:', tokenData.usuario);

        res.json({
            success: true,
            user: {
                id: tokenData.user_id,
                nome: tokenData.nome,
                usuario: tokenData.usuario
            },
            token: token
        });

    } catch (error) {
        console.error('‚ùå [VERIFY-TOKEN] Erro:', error);
        res.status(500).json({ error: 'Erro interno do servidor' });
    }
});

function parseFaceData(raw) {
    if (!raw) return null;
    if (typeof raw === 'object' && !Buffer.isBuffer(raw)) return raw;
    try {
        return JSON.parse(raw);
    } catch (e) {
        console.warn('‚ö†Ô∏è face_data inv√°lido detectado, ignorando parse:', e.message);
        return null;
    }
}

async function resolveFaceIdFromStoredData(faceImageBuffer, faceData) {
    const parsedData = parseFaceData(faceData);

    if (faceImageBuffer) {
        const detection = await azureFaceService.detectFace(faceImageBuffer);
        if (detection.success && detection.faces.length > 0) {
            return {
                faceId: detection.faces[0].faceId,
                faceAttributes: detection.faces[0].faceAttributes
            };
        }
    }

    if (parsedData?.faceId) {
        return {
            faceId: parsedData.faceId,
            faceAttributes: parsedData.faceAttributes || null
        };
    }

    return null;
}

// Rota para upload e verifica√ß√£o facial
router.post('/face-verification', upload.single('faceImage'), async (req, res) => {
    try {
        await ensureFaceImageColumn();

        const { token } = req.body;
        const imageFile = req.file;

        if (!token || !imageFile) {
            return res.status(400).json({ error: 'Token e imagem s√£o obrigat√≥rios' });
        }

        // Verificar token
        const tokenResult = await pool.query(
            `SELECT vt.*, u.id as user_id, u.face_data, u.face_image 
             FROM verification_tokens vt 
             JOIN usuarios u ON vt.user_id = u.id 
             WHERE vt.token = $1 AND vt.expires_at > NOW() AND vt.used = false`,
            [token]
        );

        if (tokenResult.rows.length === 0) {
            return res.status(400).json({ error: 'Token inv√°lido ou expirado' });
        }

    const tokenData = tokenResult.rows[0];
        const userId = tokenData.user_id;
    const existingFaceData = parseFaceData(tokenData.face_data);
    const existingFaceImage = tokenData.face_image;

        // Detectar rosto na imagem enviada
        const faceDetectionResult = await azureFaceService.detectFace(imageFile.buffer);

        if (!faceDetectionResult.success || faceDetectionResult.faces.length === 0) {
            return res.status(400).json({ 
                error: 'Nenhum rosto detectado na imagem. Tente novamente com uma foto mais clara.' 
            });
        }

        if (faceDetectionResult.faces.length > 1) {
            return res.status(400).json({ 
                error: 'M√∫ltiplos rostos detectados. Por favor, envie uma foto com apenas um rosto.' 
            });
        }

        const detectedFace = faceDetectionResult.faces[0];
        let verificationResult;

        // üîí VERIFICA√á√ÉO ANTI-DUPLICIDADE
        // Buscar TODOS os usu√°rios verificados com dados faciais (exceto o atual)
        const allVerifiedUsers = await pool.query(
            `SELECT id, usuario, face_data, face_image 
             FROM usuarios 
             WHERE is_verified = true 
             AND (face_data IS NOT NULL OR face_image IS NOT NULL)
             AND id != $1`,
            [userId]
        );

        // Verificar se o rosto j√° existe em outra conta
        for (const existingUser of allVerifiedUsers.rows) {
            try {
                const storedFace = await resolveFaceIdFromStoredData(existingUser.face_image, existingUser.face_data);
                if (!storedFace?.faceId) continue;

                const duplicateCheck = await azureFaceService.verifyFaces(
                    storedFace.faceId,
                    detectedFace.faceId
                );

                if (duplicateCheck.success && duplicateCheck.isIdentical) {
                    console.log(`‚ö†Ô∏è Tentativa de duplicidade detectada! Usu√°rio ${userId} tentou usar rosto j√° cadastrado na conta: ${existingUser.usuario}`);
                    return res.status(403).json({ 
                        error: '‚ùå Este rosto j√° est√° cadastrado em outra conta!',
                        message: 'Detectamos que este rosto j√° foi usado para verifica√ß√£o de outra conta. Cada pessoa pode ter apenas uma conta verificada.',
                        duplicate: true
                    });
                }
            } catch (dupError) {
                console.warn(`‚ö†Ô∏è Falha ao comparar rosto com usu√°rio ${existingUser.id}:`, dupError.message);
            }
        }

        const currentStoredFace = await resolveFaceIdFromStoredData(existingFaceImage, existingFaceData);

        if (currentStoredFace?.faceId) {
            verificationResult = await azureFaceService.verifyFaces(
                currentStoredFace.faceId,
                detectedFace.faceId
            );

            if (!verificationResult.success || !verificationResult.isIdentical) {
                return res.status(400).json({ 
                    error: 'Verifica√ß√£o facial falhou. O rosto n√£o corresponde aos dados existentes.',
                    confidence: verificationResult.confidence
                });
            }
        } else {
            // Primeira verifica√ß√£o (sem dados pr√©vios)
            verificationResult = { success: true, isIdentical: true, confidence: 1.0 };
        }

        // Marcar token como usado
        await pool.query('UPDATE verification_tokens SET used = true WHERE token = $1', [token]);

        // Atualizar usu√°rio como verificado e salvar dados faciais
        const faceData = {
            faceId: detectedFace.faceId,
            faceAttributes: detectedFace.faceAttributes,
            verifiedAt: new Date().toISOString()
        };

        await pool.query(
            'UPDATE usuarios SET is_verified = true, face_data = $1, face_image = $2, updated_at = CURRENT_TIMESTAMP WHERE id = $3',
            [JSON.stringify(faceData), imageFile.buffer, userId]
        );

        res.json({
            success: true,
            message: 'Verifica√ß√£o facial realizada com sucesso!',
            confidence: verificationResult.confidence,
            isFirstVerification: !currentStoredFace
        });

    } catch (error) {
        console.error('Erro na verifica√ß√£o facial:', error);
        res.status(500).json({ 
            error: 'Erro interno do servidor durante a verifica√ß√£o facial',
            details: error.message 
        });
    }
});

// Rota para obter status de verifica√ß√£o do usu√°rio
router.get('/status/:userId', async (req, res) => {
    try {
        const { userId } = req.params;

        const userResult = await pool.query(
            'SELECT is_verified, face_data IS NOT NULL as has_face_data FROM usuarios WHERE id = $1',
            [userId]
        );

        if (userResult.rows.length === 0) {
            return res.status(404).json({ error: 'Usu√°rio n√£o encontrado' });
        }

        const user = userResult.rows[0];

        res.json({
            success: true,
            isVerified: user.is_verified,
            hasFaceData: user.has_face_data
        });

    } catch (error) {
        console.error('Erro ao obter status de verifica√ß√£o:', error);
        res.status(500).json({ error: 'Erro interno do servidor' });
    }
});

module.exports = router;